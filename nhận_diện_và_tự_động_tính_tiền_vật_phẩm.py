# -*- coding: utf-8 -*-
"""Nhận Diện và Tự động tính tiền vật phẩm

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1z0PNxumxhJH0yQXnLoK3VeUL1uLlPLcX

#**How to Train YOLO11 Object Detection Model on a Custom Dataset**
"""

from google.colab import drive
drive.mount('/content/gdrive')

!nvidia-smi

"""**Bước 01 # Cài đặt gói Ultralytics**"""

!pip install ultralytics

"""**Bước 02 # Nhập tất cả các thư viện cần thiết**"""

import ultralytics
ultralytics.checks()

from ultralytics import YOLO
from IPython.display import Image

"""**Bước # 03 Tải Bộ dữ liệu từ Roboflow xuống**"""

!pip install roboflow

from roboflow import Roboflow
rf = Roboflow(api_key="d4bQR9AcEeO4r58GEvOy")
project = rf.workspace("nhi-7eti8").project("supermarket-products-yfwwl")
version = project.version(1)
dataset = version.download("yolov11")

dataset.location

"""**Bước # 04 Huấn luyện Mô hình YOLO11 trên Bộ dữ liệu vừa tạo**"""

!yolo task=detect mode=train data={dataset.location}/data.yaml model="yolo11n.pt" epochs=40 imgsz=640

"""**Bước # 05 Kiểm tra kết quả đã train**"""

import torch

# Đường dẫn đến file mô hình đã huấn luyện
model_path = "/content/gdrive/MyDrive/AI/detect/train/weights/best.pt"  # Thay "/path/to" bằng đường dẫn tới tệp best.pt

# Tải mô hình
model = torch.load(model_path, map_location=torch.device('cpu'))

# In toàn bộ thông tin trong mô hình
print("Keys in the model:", model.keys())

# In thông tin cụ thể
if 'model' in model:
    print("\nModel architecture:\n", model['model'])  # Kiến trúc mô hình
if 'epoch' in model:
    print("\nEpoch:", model['epoch'])  # Số epoch đã huấn luyện
if 'optimizer' in model:
    print("\nOptimizer state:\n", model['optimizer'])  # Trạng thái tối ưu hóa
if 'train_args' in model:
    print("\nTraining arguments:\n", model['train_args'])  # Thông số huấn luyện

Image("/content/gdrive/MyDrive/AI/detect/train/confusion_matrix.png", width=600)

Image("/content/gdrive/MyDrive/AI/detect/train/results.png", width=600)

Image("/content/gdrive/MyDrive/AI/detect/train/val_batch2_pred.jpg", width=600)

from google.colab import drive
drive.mount('/content/gdrive')

import os
import shutil

# Đảm bảo rằng thư mục đích tồn tại
os.makedirs('/content/gdrive/MyDrive/AI', exist_ok=True)

# Sao chép các file từ thư mục nguồn vào thư mục đích
shutil.copytree('/content/runs', '/content/gdrive/MyDrive/AI', dirs_exist_ok=True)

"""NHẬN DẠNG ẢNH"""

!yolo task=detect mode=predict model= /content/gdrive/MyDrive/AI/detect/train/weights/best.pt conf=0.25 source=/content/gdrive/MyDrive/testYoLO/test_anh.jpg save=True

Image("/content/runs/detect/predict/test_anh.jpg", width=600)

"""**HỆ THỐNG TÍNH TIỀN BẰNG HÌNH ẢNH**"""

import cv2
import matplotlib.pyplot as plt

# Load mô hình YOLO
model = YOLO("/content/gdrive/MyDrive/AI/detect/train/weights/best.pt")

# Dự đoán đối tượng trên hình ảnh
image_path = "/content/gdrive/MyDrive/testYoLO/test_anh.jpg"  # Đường dẫn ảnh
image = cv2.imread(image_path)
results = model.predict(source=image_path, conf=0.2)

# Xử lý kết quả
total_price = 0
for box in results[0].boxes:
    # Tọa độ và nhãn
    x1, y1, x2, y2 = map(int, box.xyxy[0])
    label = results[0].names[int(box.cls)]

    if "-" in label:
        product_name, price = label.split("-", 1)  # Chỉ tách thành 2 phần
        product_name = product_name.strip()  # Loại bỏ khoảng trắng thừa

        # Kiểm tra giá có đúng định dạng và có chứa "VND"
        if price.endswith("VND") and price[:-3].isdigit():
            price_value = float(price[:-3])  # Lấy giá trị số (loại bỏ "VND")
            total_price += price_value
        else:
            price_value = "Unknown"  # Giá không hợp lệ
    else:
        product_name, price_value = label, "Unknown"  # Nhãn không hợp lệ

    # Vẽ bounding box và ghi thông tin
    label_text = f"{product_name}: {price_value} VND"
    cv2.rectangle(image, (x1, y1), (x2, y2), (0, 255, 0), 2)
    cv2.putText(image, label_text, (x1, y1 - 10), cv2.FONT_HERSHEY_SIMPLEX,
                0.5, (0, 255, 0), 2)

# 4. Hiển thị tổng giá trị trên hình ảnh
total_text = f"Total: {total_price} VND"
cv2.putText(image, total_text, (10, 30), cv2.FONT_HERSHEY_SIMPLEX,
            1, (255, 0, 0), 2, cv2.LINE_AA)

# 5. Hiển thị hình ảnh kết quả
image_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
plt.figure(figsize=(10, 10))
plt.imshow(image_rgb)
plt.axis("off")
plt.show()

"""**HỆ THÔNG TÍNH TIỀN TRÊN VIDEO**"""

import cv2  # Thêm import cv2 để sử dụng OpenCV
import imageio
import os
from google.colab.patches import cv2_imshow
from ultralytics import YOLO  # Đảm bảo đã import YOLO từ thư viện ultralytics

# Load mô hình YOLO
model = YOLO("/content/gdrive/MyDrive/AI/detect/train/weights/best.pt")

# Đường dẫn đến video
video_path = "/content/gdrive/MyDrive/testYoLO/2.mp4"  # Đường dẫn video

# Mở video với imageio
vid = imageio.get_reader(video_path)

# Tạo thư mục để lưu kết quả (nếu chưa tồn tại)
output_folder = "/content/runs/detect/predict"
os.makedirs(output_folder, exist_ok=True)

# Đọc video đầu vào để lấy thông tin về kích thước
frame = vid.get_data(0)
height, width, _ = frame.shape

# Tạo một writer để lưu video kết quả
output_video_path = "/content/runs/detect/predict1.mp4"
fourcc = cv2.VideoWriter_fourcc(*'mp4v')  # Định dạng video
out = cv2.VideoWriter(output_video_path, fourcc, 20.0, (width, height))

# Tạo cửa sổ hiển thị video
for idx, frame in enumerate(vid):
    # Chuyển đổi từ RGB sang BGR nếu cần sử dụng OpenCV
    frame = cv2.cvtColor(frame, cv2.COLOR_RGB2BGR)

    # Dự đoán đối tượng trên frame và lưu kết quả
    results = model.predict(source=frame, conf=0.2, save=True, project=output_folder, name=f"frame_{idx}")

    # Xử lý kết quả
    total_price = 0
    for box in results[0].boxes:
        # Tọa độ và nhãn
        x1, y1, x2, y2 = map(int, box.xyxy[0])
        label = results[0].names[int(box.cls)]

        if "-" in label:
            product_name, price = label.split("-", 1)  # Chỉ tách thành 2 phần
            product_name = product_name.strip()  # Loại bỏ khoảng trắng thừa

            # Kiểm tra giá có đúng định dạng và có chứa "VND"
            if price.endswith("VND") and price[:-3].isdigit():
                price_value = float(price[:-3])  # Lấy giá trị số (loại bỏ "VND")
                total_price += price_value
            else:
                price_value = "Unknown"  # Giá không hợp lệ
        else:
            product_name, price_value = label, "Unknown"  # Nhãn không hợp lệ

        # Vẽ bounding box và ghi thông tin
        label_text = f"{product_name}: {price_value} VND"
        frame = cv2.rectangle(frame, (x1, y1), (x2, y2), (0, 255, 0), 2)
        frame = cv2.putText(frame, label_text, (x1, y1 - 10), cv2.FONT_HERSHEY_SIMPLEX,
                            0.5, (255, 0, 0), 2)

    # Hiển thị tổng giá trị trên video
    total_text = f"Total: {total_price} VND"
    frame = cv2.putText(frame, total_text, (10, 30), cv2.FONT_HERSHEY_SIMPLEX,
                        1, (255, 0, 0), 2, cv2.LINE_AA)

    # Hiển thị video với các bounding box và thông tin
    cv2_imshow(frame)  # Dùng cv2_imshow thay vì cv2.imshow

    # Lưu frame đã xử lý vào video output
    out.write(frame)

# Giải phóng tài nguyên
vid.close()
out.release()

"""**WEBCAM**"""

import logging
from ultralytics import YOLO

# Tắt các thông báo từ YOLO
logging.getLogger("ultralytics").setLevel(logging.ERROR)

from IPython.display import display, Javascript
from google.colab.output import eval_js
from base64 import b64decode, b64encode
import cv2
import numpy as np
import PIL
import io
import time
from ultralytics import YOLO
from collections import defaultdict

# Load the YOLO model
model = YOLO("/content/gdrive/MyDrive/AI/detect/train/weights/best.pt")  # Path to your trained YOLO model

# Function to convert the JavaScript object into an OpenCV image
def js_to_image(js_reply):
    image_bytes = b64decode(js_reply.split(',')[1])
    jpg_as_np = np.frombuffer(image_bytes, dtype=np.uint8)
    img = cv2.imdecode(jpg_as_np, flags=1)
    return img

# Function to convert OpenCV Rectangle bounding box image into base64 byte string
def bbox_to_bytes(bbox_array):
    bbox_PIL = PIL.Image.fromarray(bbox_array, 'RGBA')
    iobuf = io.BytesIO()
    bbox_PIL.save(iobuf, format='png')
    bbox_bytes = 'data:image/png;base64,{}'.format((str(b64encode(iobuf.getvalue()), 'utf-8')))
    return bbox_bytes

# JavaScript to create the live video stream from the webcam
def video_stream():
    js = Javascript('''
    var video;
    var div = null;
    var stream;
    var captureCanvas;
    var imgElement;
    var labelElement;

    var pendingResolve = null;
    var shutdown = false;

    function removeDom() {
       stream.getVideoTracks()[0].stop();
       video.remove();
       div.remove();
       video = null;
       div = null;
       stream = null;
       imgElement = null;
       captureCanvas = null;
       labelElement = null;
    }

    function onAnimationFrame() {
      if (!shutdown) {
        window.requestAnimationFrame(onAnimationFrame);
      }
      if (pendingResolve) {
        var result = "";
        if (!shutdown) {
          captureCanvas.getContext('2d').drawImage(video, 0, 0, 640, 480);
          result = captureCanvas.toDataURL('image/jpeg', 0.8)
        }
        var lp = pendingResolve;
        pendingResolve = null;
        lp(result);
      }
    }

    async function createDom() {
      if (div !== null) {
        return stream;
      }

      div = document.createElement('div');
      div.style.border = '2px solid black';
      div.style.padding = '3px';
      div.style.width = '100%';
      div.style.maxWidth = '600px';
      document.body.appendChild(div);

      const modelOut = document.createElement('div');
      modelOut.innerHTML = "<span>Status:</span>";
      labelElement = document.createElement('span');
      labelElement.innerText = 'No data';
      labelElement.style.fontWeight = 'bold';
      modelOut.appendChild(labelElement);
      div.appendChild(modelOut);

      video = document.createElement('video');
      video.style.display = 'block';
      video.width = div.clientWidth - 6;
      video.setAttribute('playsinline', '');
      video.onclick = () => { shutdown = true; };
      stream = await navigator.mediaDevices.getUserMedia(
          {video: { facingMode: "environment"}});
      div.appendChild(video);

      imgElement = document.createElement('img');
      imgElement.style.position = 'absolute';
      imgElement.style.zIndex = 1;
      imgElement.onclick = () => { shutdown = true; };
      div.appendChild(imgElement);

      const instruction = document.createElement('div');
      instruction.innerHTML =
          '<span style="color: red; font-weight: bold;">' +
          'When finished, click here or on the video to stop this demo</span>';
      div.appendChild(instruction);
      instruction.onclick = () => { shutdown = true; };

      video.srcObject = stream;
      await video.play();

      captureCanvas = document.createElement('canvas');
      captureCanvas.width = 640;
      captureCanvas.height = 640;
      window.requestAnimationFrame(onAnimationFrame);

      return stream;
    }
    async function stream_frame(label, imgData) {
      if (shutdown) {
        removeDom();
        shutdown = false;
        return '';
      }

      var preCreate = Date.now();
      stream = await createDom();

      var preShow = Date.now();
      if (label != "") {
        labelElement.innerHTML = label;
      }

      if (imgData != "") {
        var videoRect = video.getClientRects()[0];
        imgElement.style.top = videoRect.top + "px";
        imgElement.style.left = videoRect.left + "px";
        imgElement.style.width = videoRect.width + "px";
        imgElement.style.height = videoRect.height + "px";
        imgElement.src = imgData;
      }

      var preCapture = Date.now();
      var result = await new Promise(function(resolve, reject) {
        pendingResolve = resolve;
      });
      shutdown = false;

      return {'create': preShow - preCreate,
              'show': preCapture - preShow,
              'capture': Date.now() - preCapture,
              'img': result};
    }
    ''')
    display(js)

# Function to get video frames and perform object detection
def video_frame(label, bbox):
    data = eval_js('stream_frame("{}", "{}")'.format(label, bbox))
    return data

# Start streaming video from webcam
video_stream()
label_html = 'Đang lấy hình ảnh...'
bbox = ''
total_price = 0
products = defaultdict(int)
detected_products = []

# Tạo biến để đếm số khung hình và bỏ qua
skip_counter = 0
skip_frames = 3

while True:
    js_reply = video_frame(label_html, bbox)
    if not js_reply:
        break

    # Bỏ qua một số khung hình
    if skip_counter < skip_frames:
        skip_counter += 1
        continue
    else:
        skip_counter = 0

    # Convert JS response to OpenCV Image
    img = js_to_image(js_reply["img"])

    # Run YOLO object detection on the frame
    results = model.predict(source=img, conf=0.25)

    # Create transparent overlay for bounding boxes
    bbox_array = np.zeros([640, 640, 4], dtype=np.uint8)

    # Process the results from YOLO
    for box in results[0].boxes:
        x1, y1, x2, y2 = map(int, box.xyxy[0])
        label = results[0].names[int(box.cls)]
        price_value = "Unknown"

        # Trích xuất giá trị từ nhãn, loại bỏ 'VND' và các ký tự không hợp lệ
        if "-" in label:
            product_name, price = label.split("-", 1)  # Tách tên sản phẩm và giá
            product_name = product_name.strip()

            # Xử lý phần giá, loại bỏ 'VND' và các ký tự không phải số
            price_value = price.split(" ")[0].strip()  # Lấy giá trị trước dấu cách (nếu có)

            # Loại bỏ tất cả các ký tự không phải số (như "VND")
            price_value = ''.join(filter(str.isdigit, price_value))

            if price_value:  # Nếu giá trị sau khi lọc là số hợp lệ
                total_price += int(price_value)  # Cộng vào tổng tiền
                products[product_name] += 1  # Tăng số lượng sản phẩm

                # Lưu thông tin sản phẩm vào danh sách
                detected_products.append({
                    'product_name': product_name,
                    'price': int(price_value)
                })
            else:
                price_value = "Unknown"
        else:
            product_name, price_value = label, "Unknown"

        # Draw bounding box and label
        cv2.rectangle(bbox_array, (x1, y1), (x2, y2), (255, 0, 0), 2)
        cv2.putText(bbox_array, f"{product_name}: {price_value}", (x1, y1 - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 0, 0), 2)

    # Add total price to the image
    cv2.putText(bbox_array, f"Total: {total_price} VND", (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 1, (255, 255, 0), 2)

    bbox_array[:, :, 3] = (bbox_array.max(axis=2) > 0).astype(int) * 255
    bbox_bytes = bbox_to_bytes(bbox_array)
    bbox = bbox_bytes  # Update bbox for next frame

import pandas as pd
from tabulate import tabulate

# Tạo DataFrame từ danh sách 'detected_products'
df = pd.DataFrame(detected_products)

# Tính số lượng sản phẩm, tổng tiền và giữ giá sản phẩm ban đầu
df_summary = df.groupby('product_name').agg(
    quantity=('price', 'size'),
    total_price=('price', 'sum'),
    price=('price', 'first')  # Giữ giá sản phẩm đầu tiên
).reset_index()
# Tính tổng tiền
total_amount = df_summary['total_price'].sum()

# Hiển thị bảng với tabulate
print(tabulate(df_summary, headers='keys', tablefmt='pretty', showindex=False))

# In ra tổng tiền
print(f"\n Total: {total_amount} VND")